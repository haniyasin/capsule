* Введение
  Здесь описывается только api с точки зрения приложения, которое капсулируется.
  Каждый раздел, это модуль или папка с модулями(папками).
  При этом модули, предназначенные для приложения и модули, которые имеют другие предназначение(нужно для 
  deployer или чего-то подобного) отделены

* for application
** timer
     фунциональность полностью аналогична setTimeout и setInterval просто с иным API.
     Данный модуль есть просто потому, что далеко не везде где есть javascript - есть браузерные функции
     работы с таймером.
     API простейшнее:
     create(callback, millisec, cyclic)
     #+BEGIN_SRC javascript
     var timer = require('modules/timer');
     timer.create(function(){ console.log('hello once')}, 100, false); //создаст таймер с единичным срабатыванием
     var tobj = timer.create(function() { console.log('hello many times'); }, 200, true); /*создаст таймер
     который будет вызывать callback каждые 200 милисекунд. Такой таймер можно уничтожить с помощью
     tobj.destroy(); */
     #+END_SRC
** storage
     Предоставляет возможность сохранять объекты по ключу, обновлять их частями и извлекать только то, что
     нужно. По сути максимально простая db, максимально архитектурно заточена под  репликацию. Версионная
** http_requester
     Аналог xhr, но кросплатформенный
** http_responder
     Сильно упрощённый вариант web сервера, по api скорее похож на xhr
** ui
     набор модулей для формирования пользовательского интерфейса. Как и все остальный модули, главная задача
     ui быть кросплатформенным, это значит что используя один и тот же api вы можете написать приложение
     для web браузера или обычное desktop приложение. 
*** Compositer
       Основной модуль, реализующий логику ui элементов, способы работы с событиями и анимацию
       Концепция compositer очень проста, на ней основаны все иные ui элементы. Он оперирует следующими
       понятиями:
       + element
	 То чем манипулируют, то есть это элемент ui. В современной терминологии element может быть:
	 + window|surface
	   когда в него помещают другие элементы, он используется как холст
	 + widget|control
	   обычно это то же окно, но с содержимым, с которым пользователь взаимодействует
	 
         В общем случае element это прямоугольная область, над которой можно совершать манипуляции с помощью
	 animation и которая может получать события.
	 Все элементы с точки зрения animation и event одинаковы подобны простейшему element - frame
       + animation
	 Последовательность изменения свойств элемента. В анимации задаются цепочки изменения свойств и время,
	 за которое эти изменения должны наступить. Есть и способ немедленного изменения свойств, но animation
	 позволяет не только растянуть изменение свойств во времени(скажем реализовать плавное перемещение
	 элемента), но это также полноценный объект, который генерирует события(например анимация завершена)
         , которым можно управлять(к примеру остановить).
       + event
	 Все события обрабатываются единым образом. К элементам можно прикрепить обработчик того или иного 
	 события. Событиями зовётся всё, что происходит(клавиатурный ввод, движение курсора, завершение
	 анимации, какие-либо изменения элементов и тд)

**** Elements
     Общие свойства всех элементов, изменяемые общим образом через element_change_props или animation:
     + геометрические свойства
       Значения могут быть в %(рассчитываются относительно родителя) и в пикселях
       + x
         позиция элемента относительно родителя слева
       + y
       позиция сверху
       + width  
	 ширина элемента
       + height
	 высота элемента

     + прочие свойства
       + opacity
	 непрозрачность. Нулевое значение - полная прозрачность. Может быть указана в процентах или вещественным числом от 0 до 1
       + z_index
	 номер слоя, на котором расположен элемент в родителе. Позволяет накладывать один элемент на другой в рамках одного родителя. Значение от нуля до 255, чем выше число тем ближе к зрителю.
***** frame
      Прямоугольная область без какого-либо самостоятельного наполнения. Основная цель, быть поверхностью-контейнером для других элементов. В один фрейм можно добавить любое число других элементов
      + методы
	+ frame_create(info)
	  Создаёт frame, возвращает id
	+ frame_destroy(id)
	  Уничтожает frame
        + frame_add(frame_id, child_id)
	  Добавить какой-либо элемент к фрейму.
        + frame_remove(frame_id,child_id)
	  Удалить элемент из родительского фрейма
***** image
      Содержит и отображает изображение, пока что поддерживается png и svg.
      + методы
	+ image_create(info)
	  Создаёт изображение, обычный мето создания. Единственный момент, info содержит поле source, которое должно указывать на объект types/image
	+ image_destroy(id)
	  Уничтожает image
***** text
      Содержит текст, пока документации не будет, потому что элемент претерпит существенные изменения.
***** button
*****
***** entry
**** Animation
     В основу механизма анимации положен массив объектов следующего содержания:
     #+BEGIN_SRC js
       {
           duration : '200', //Время, за которое нужно произвести изменения. Значение в миллисекундах
           actions : { //в этом объекте могут быть любые свойства элемента(x, y, width, height, opacity, z_index и тд)
               x : 10 //значение прибавляется к текущему значения этого свойства элемента. При этом используется тот тип значения, который был изначально задан. То есть если значение задано было в процентах, то прибавляются проценты, если в пикселях, то прибавляются пиксели.
               y : -20 //значение отнимается от текущего значения этого свойства элемента.
           }
       }
     #+END_SRC
     Каждый элемент массива(то есть указанный выше объект) исполняется строго последовательно, начиная от 0.
     + методы
       + anim_create(chain)
	 создаёт анимацию
	 chain - это массив объектов, как указано выше. Возвращает id созданной анимации.
       + anim_destroy(id)
	 уничтожает анимацию
       + anim_bind(element_id, animation_id)
	 привязывает созданную анимацию к определённому элементу. Одна и таже анимация может быть привязана к множеству элементов.
	 Возвращает id привязанной анимации.
       + anim_unbind(element_id, binded_animation_id)
	 Отвязывает от элемента анимацию.
       + anim_start(binded_animation_id)
	 Начинает исполнение анимации
       + anim_stop(binded_animation_id
	 Прекращает исполнение анимации
	 
**** Events
     + Методы 
       ```event_register(element, event_name, callback)``` - устанавливает callback
       + element
	 тот элемент, с которого мы хотим ловить сообщение
       + event_name
	 имя события, которое хотим отлавливать
       + callback
	 функция, которая будет вызвана в случае наступления события
       ```event_unregister(element, event_name)``` - убирает callback
     + Виды событий
       + pointer_in
       + pointer_out
       + pointer_down
       + pointer_up
       + pointer_motion
       + key_down
       + key_up
       + animation_stopped


*** video
       модуль реализующий video элемент
*** dnd
       реализация drag and drop
*** filechooser
       элемент для запрашивания и обработки файлов от пользователя

* for hacking
