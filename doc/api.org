* Введение
  Здесь описывается только api с точки зрения приложения, которое капсулируется.
  Каждый раздел, это модуль или папка с модулями(папками).
  При этом модули, предназначенные для приложения и модули, которые имеют другие предназначение(нужно для 
  deployer или чего-то подобного) отделены

* for application
** timer
     фунциональность полностью аналогична setTimeout и setInterval просто с иным API.
     Данный модуль есть просто потому, что далеко не везде где есть javascript - есть браузерные функции
     работы с таймером.
     API простейшнее:
     create(callback, millisec, cyclic)
     ```javascript
     var timer = require('modules/timer');
     timer.create(function(){ console.log('hello once')}, 100, false); //создаст таймер с единичным срабатыванием
     var tobj = timer.create(function() { console.log('hello many times'); }, 200, true); /*создаст таймер
     который будет вызывать callback каждые 200 милисекунд. Такой таймер можно уничтожить с помощью
     tobj.destroy(); */
     ```
** storage
     Предоставляет возможность сохранять объекты по ключу, обновлять их частями и извлекать только то, что
     нужно. По сути максимально простая db, максимально архитектурно заточена под  репликацию. Версионная
** http_requester
     Аналог xhr, но кросплатформенный
** http_responder
     Сильно упрощённый вариант web сервера, по api скорее похож на xhr
** ui
     набор модулей для формирования пользовательского интерфейса. Как и все остальный модули, главная задача
     ui быть кросплатформенным, это значит что используя один и тот же api вы можете написать приложение
     для web браузера или обычное desktop приложение. 
*** Compositer
       Основной модуль, реализующий логику ui элементов, способы работы с событиями и анимацию
       Концепция compositer очень проста, на ней основаны все иные ui элементы. Он оперирует следующими
       понятиями:
       + element
	 То чем манипулируют, то есть это элемент ui. В современной терминологии element может быть:
	 + window|surface
	   когда в него помещают другие элементы, он используется как холст
	 + widget|control
	   обычно это то же окно, но с содержимым, с которым пользователь взаимодействует
	 
         В общем случае element это прямоугольная область, над которой можно совершать манипуляции с помощью
	 animation и которая может получать события.
	 Все элементы с точки зрения animation и event одинаковы подобны простейшему element - frame
       + animation
	 Последовательность изменения свойств элемента. В анимации задаются цепочки изменения свойств и время,
	 за которое эти изменения должны наступить. Есть и способ немедленного изменения свойств, но animation
	 позволяет не только растянуть изменение свойств во времени(скажем реализовать плавное перемещение
	 элемента), но это также полноценный объект, который генерирует события(например анимация завершена)
         , которым можно управлять(к примеру остановить).
       + event
	 Все события обрабатываются единым образом. К элементам можно прикрепить обработчик того или иного 
	 события. Событиями зовётся всё, что происходит(клавиатурный ввод, движение курсора, завершение
	 анимации, какие-либо изменения элементов и тд)

**** Elements
**** Animation
**** Events
     + Методы 
       ```event_register(element, event_name, callback)``` - устанавливает callback
       + element
	 тот элемент, с которого мы хотим ловить сообщение
       + event_name
	 имя события, которое хотим отлавливать
       + callback
	 функция, которая будет вызвана в случае наступления события
       ```event_unregister(element, event_name)``` - убирает callback
     + Виды событий
       + pointer_in
       + pointer_out
       + pointer_down
       + pointer_up
       + pointer_motion
       + key_down
       + key_up
       + animation_stopped

*** video
       модуль реализующий video элемент
*** dnd
       реализация drag and drop
*** filechooser
       элемент для запрашивания и обработки файлов от пользователя

* for hacking
