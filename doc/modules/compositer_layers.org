* Виды возможных компосайтеров:
+ fast( web, evas)
  Эти компосайтеры напрямую подключены к капсуле как модели, и скорее всего полностью реализуют апи компосайтера
  самостоятельно, целиком.
+ slow( web_static, remote web, remote evas, remote javame)
  Эти компосайтеры можно разделить на два типа
  + full
    полностью реализующие апи compositer, но работающие медленно по различным причинам, может производительность,
    может потому, что работают как удалённые модули капсулы
  + parted
    разделённые на части. На данный момент пока только одна идея - отделить основую логику компосайтера, от устройтва
    вывова и ввода. Грубо говоря есть две части - compositer.core и compositer.io.
** сompositer.io
   Вся работа с compositer.core происходит через два метода
   frame = {
       surfaces = [
        {
	'width' : 20,
	'heigth' : 30,
	'w' : 10,
	'h' : 10,
	'image' : 'base64data'
	},
	{
	'width' : 40,
	'heigth' : 40,
	'w' : 15,
	'h' : 15,
	'image' : 'base64data'
	}
       ]
   }
   frame = frame_get();
   set_configuration(width, heigth, speed);
   events = {
   'pointer_in' : 'bla',
   'key_down' : 'bla'
   }
   send_events(events);
   Есть два варианта.
   + only root frame
     Только один главный фрейм во всю рабочую область. Его переодически нужно обновлять. Сообщения также 
     передаются только от этого фрейма. Всю остальную работу по формированию других фреймов и сообщений от них,
     делает compositer.core.
     Это как отправлять новый кадр видео и отлавливать события.
   + surfaces, events
     Главный фрейм и возможность строить его содержимое рисованием rectами. Всю остальную работу по формированию,
     фреймов и сообщений от них делает compositer.core.
     По сути это подобно предыдущему варианту, но есть возможность обновлять только часть содержимого кадра 
     прямоугольными областями произвольного размера и с любым расположением.
  
   Оба варианта предполагают деструктивное, stateless, обновление кадра. То есть никакого управления фреймами
   или прямоугольными областями, только их рисование.
   Разница же в том, что вариант с surfaces позволяет реализовать эффективную и быструю работу компосайтера при
   минимальной нагрузе на канал(если compositer.io работает поверх http). В то же время первый вариант проще
   в реализации.
   Оба варианта используют один и тот же api, разница лишь в том, что первый вариант обновляет только одну 
   поверхность, считая её root frame и соотвественно игнорируя её размеры.
** compositer.core
   api этого модуля идентично compositer, разница же в том, что для работы ему необходим бэкэнд, compositer.io,
   для которого реализуется дополнительное api. Которое пробрасывается через механизм remote_module, если нужно,
   чтобы compositer.io работал удалённо, поверх например http.
*** api для подключения compositer.io
```javascript
cc.io.frame_get();
cc.io.set_configuration(width, height, speed);
cc.send_events(events);
```
