* transport module class

** description
   Обопщённый, абстрактный интерфейс до таких низлежащих транспортов как: direct, zeromq, AJAX, Browser_SCRIPT, websockets и тд.
   Полностью асинхронный.

** synopsis
```javascript
   var context = { 'url' : 'tcp://127.0.0.1:27000' }
   var server = transport.zmq.create(context, transport_features_server);
   server.on_connect(function(socket){
				      socket.on_msg(function(msg){
					console.log(msg)
					});
				    }, 0 );
   var client = transport.zmq.create(context, transport_features_client);
    
   client.send('something like a cow shit');
```
Пример выше создаст прнимающий транспорт, затем оптравляющий. После этого, отправляющий пошлёт сообщение с каким-то коровьим говном и его отпечатает каллбек принимающего.
server.on_connect значит отрабатывать каллбек, когда подключается клиент. В каллбэк передаётся сокет, с помощью
которого принимаются и отправляются сообщения

** api
```javascript
function create(context, features)
```
создаёт экземпляр транспорта, принимающий или отправляющий. url в контексте у принимающего транспорта и отправляющего
может не совпадать. Например принимающий может иметь пустую строку, что может означать - принимать соединения на 
любом из доступных адресов.

*** параметры
+ context
  Содержит url адрес. 
  
  + features
  Флаги возможностей, допустимы следующие флаги:
  
  - client : 0x00000001
    коонектящийся, поддерживает множество входных и выходных сообщений асинхронно
  
  - server : 0x00000002
    принимающий, поддерживает множество входных и выходных сообщений асинхронно
  
  - need_address : 0x00000100
    нуждается в асдресе при создании или нет. Если 1, то нужно, если 0, то не нуждается. Некоторые типы транспортов не могут иметь адреса впринципе, например принимающий сообщения вебворкер.
  
  - only_one_instance : 0x00000200
    только один экземпляр транспорта возможен, если 1. Опять же имеет смысл для webworker, ajax или когда создатель капсулы устанавливает подобные ограничения даже для tcp, udp и других транспортов
  
*** возвращает
    
```javascript
{
   [[modules.transport.created_object.send][send]],
   on_msg,
   destroy
}
```

**** `send(msg_id, msg_body, callback)`
     Посылает сообщение. Количество сообщений с одиним и тем же msg_id не ограничено.
     + msg_id
       Идентификатор сообщения, может использоваться для ответа на это сообщение с той стороны, тогда callback будет вызван, когда придёт ответ. 
       Также может использоваться для посыла ответа.

     + msg_body
       содержимое сообщения, в json
       
     + callback
       функция вида:
       `func(msg_id, msg_body)`

       Вызывается, когда приходит сообщение с таким же msg_id, которое было послано. Может быть пустой строкой, тогда сообщение не предполагает ответа.
**** `on_msg(msg_id, callback, ...)

     регистрирует callback на приход сообщения, указание в качестве callback пустой строки - удаляет зарегистрированный callback.
     Cуществуют следующие events:
     + msg_id
       идентификатор сообщения, любое число, но возможен и uuid
     +  callback имеет следующий вид:
       `func(msg_id, msg_body)`, где       
       - msg_id
	 идентификатор сообщения. Используя этот идентификатор можно передать ответное сообщение. Идентификатор может быть использован повторно сколько угодно раз. Иными словами, когда сообщение приходит, используя его msg_id можно послать сколько угодно сообщений в ответ. 
       - msg_body
	 тело сообщения, содержит json

**** destroy()
  уничтожает экземпляр транспорта
