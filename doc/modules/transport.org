* transport module class

** description
   Обопщённый, абстрактный интерфейс до таких низлежащих транспортов как: direct, zeromq, AJAX, Browser_SCRIPT, websockets и тд.
   Полностью асинхронный.

** synopsis
```javascript
   var router = transport.zmq.create('tcp://127.0.0.1:27000', transport_features_router);
   router.on_msg(11,function(msg){console.log(msg)}, 0 );
   var dealer = transport.zmq.create('tcp://127.0.0.1:27000', transport_features_dealer);
   dealer.send(11, 'something like a cow shit');
```
Пример выше создаст прнимающий транспорт, затем оптравляющий. После этого, отправляющий пошлёт сообщение с каким-то коровьим говном и его отпечатает каллбек принимающего.
0 в router.on_msg значит отрабатывать каллбек на любое пришедшее сообщение.
Понятие принимающего и отправляющего здесь только с точки зрения того, кто устанавливает соединение первым. Устанавливает его первым отправляющий. Во всех остальных смыслах
работы с сообщениями они идентичны

** api
```javascript
function create(address, features)
```
создаёт экземпляр транспорта, принимающий и отправляющий отличаются только features, но также может и отличаться адрес. Например принимающий может указывать адрес в виде пустой строки или что-то вроде этого.

*** параметры
+ address 
  url адрес. Может и отсутствовать, в этом случае должен быть пустой строкой. Может быть и не url, в теории
+ features
  Флаги возможностей, допустимы следующие флаги:
  
  - dealer : 0x00000001
    коонектящийся, поддерживает множество входных и выходных сообщений асинхронно
  
  - router : 0x00000002
    принимающий, поддерживает множество входных и выходных сообщений асинхронно
  
  - need_address : 0x00000100
    нуждается в асдресе при создании или нет. Если 1, то нужно, если 0, то не нуждается. Некоторые типы транспортов не могут иметь адреса впринципе, например принимающий сообщения вебворкер.
  
  - only_one_instance : 0x00000200
    только один экземпляр транспорта возможен, если 1. Опять же имеет смысл для webworker, ajax или когда создатель капсулы устанавливает подобные ограничения даже для tcp, udp и других транспортов
  
*** возвращает
    
```javascript
{
   [[modules.transport.created_object.send][send]],
   on_msg,
   destroy
}
```

**** `send(msg_id, msg_body, callback)`
     Посылает сообщение. Количество сообщений с одиним и тем же msg_id не ограничено.
     + msg_id
       Идентификатор сообщения, может использоваться для ответа на это сообщение с той стороны, тогда callback будет вызван, когда придёт ответ. 
       Также может использоваться для посыла ответа.

     + msg_body
       содержимое сообщения, в json
       
     + callback
       функция вида:
       `func(msg_id, msg_body)`

       Вызывается, когда приходит сообщение с таким же msg_id, которое было послано. Может быть пустой строкой, тогда сообщение не предполагает ответа.
**** `on_msg(msg_id, callback, ...)

     регистрирует callback на приход сообщения, указание в качестве callback пустой строки - удаляет зарегистрированный callback.
     Cуществуют следующие events:
     + msg_id
       идентификатор сообщения, любое число, но возможен и uuid
     +  callback имеет следующий вид:
       `func(msg_id, msg_body)`, где       
       - msg_id
	 идентификатор сообщения. Используя этот идентификатор можно передать ответное сообщение. Идентификатор может быть использован повторно сколько угодно раз. Иными словами, когда сообщение приходит, используя его msg_id можно послать сколько угодно сообщений в ответ. 
       - msg_body
	 тело сообщения, содержит json

**** destroy()
  уничтожает экземпляр транспорта
