* базовые принципы и примитивы capsule API
  Хотя здесь будет описано всё API, это не касается модулей, их описани будет в них самих

** require
   Под какой бы платформой вы не исполозовали capsule, для вашего кода всегда доступна require. Её логика
   аналогична логике require в nodejs, requirejs и подобном. То есть это загрузчик commonjs модуля. 
   Работа require проста, в качестве аргумента указывается путь, и если модуль по указанному пути
   находится, то он возвращается в виде объекта. Если нет, то генерируется исключение с сообщением о том,
   по какому пути не удалось загрузить модуль.
   То есть в общем виде выглядит это так:
   
   var module = require('somemodule.js');
   
   Сразу стоит сказать, что расширение '.js' обязательно, пока что, это специфика реализации module_loader 
   для тех платформ, где require не поддерживается.

*** код, который собран с помощью capsule и код capsule/modules
    Формируется единое дерево модулей, это Первая часть единого API.
    Поэтому 'somemodule.js' будет значить capsule/somemodule.js.
    Для относительных путей нужно использовать '.' и '..' для перехода на папку вверх и вниз относительно
    текущей папки, которая содержит тот модуль, из которого вы вызываете require.
    
    То есть если у вас есть такая структура папок:
    capsule
        yourproject
            lib
                somethingusefull.js
            one.js
    
    То загрузка somethingusefull модуля из one.js будет выглядеть так:
    //one.js
    var some = require('./lib/somethingusefull.js');
    
*** код capsule/platforms/someplatform/modules
    В первом приближении всё также как в предыдущем случае за исключением того, что не формируется единое
    дерево модулей, точнее говоря оно
    + может формироваться
      если работа с модулями происходит внутри сформированной capsule. Это обычный случай использования.
      В этом случае все platforms/someplatform/modules помещаются в capsule/modules
    
    + а может и не формироваться
      если работа с модулями происходит без формирования capsule, целеноправленно. Это случай, когда
      модули используются не capsule, а например deployer для обеспечения своей работы. Он делает использует
      модули для тех же целей, для чего они нужны впринципе - кросплатформенность, чтобы работать одному
      и тому же коду на разных платформа.  
      В этом случае все папки остаются на местах, а значит чтобы подгрузить что-то из capsule/modules
      надо использовать такую запись
      require('modules/somemodule.js');
    
    Отсюда важное требование. Все platforms/*/modules должны использовать глобальную запись путей для
    модулей или частей, который находятся вне текущей платформы.
    Иными словами, если модулю platforms/someplatform/modules/somemodule.js потребовался parts/base32.js
    то подгружать он его _обязательно_ должен так:
    require('parts/base32.js');
    Но не так:
    require('../../../parts/base32.js');
   
    Понятно, что первый путь и проще и понятнее, но второй впринципе то работает, но только в рамках capsule.
    А без сформированной capsule не работает и выкидывает исключение.
      
