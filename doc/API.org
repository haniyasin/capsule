* Введение
  Здесь описывается только api с точки зрения приложения, которое капсулируется.
  Каждый раздел, это модуль или папка с модулями(папками).
  При этом модули, предназначенные для приложения и модули, которые имеют другие предназначение(нужно для 
  deployer или чего-то подобного) отделены

* for application
** timer
     фунциональность полностью аналогична setTimeout и setInterval просто с иным API.
     Данный модуль есть просто потому, что далеко не везде где есть javascript - есть браузерные функции
     работы с таймером.
     API простейшнее:
     create(callback, millisec, cyclic)
     #+BEGIN_SRC javascript
     var timer = require('modules/timer');
     timer.create(function(){ console.log('hello once')}, 100, false); //создаст таймер с единичным срабатыванием
     var tobj = timer.create(function() { console.log('hello many times'); }, 200, true); /*создаст таймер
     который будет вызывать callback каждые 200 милисекунд. Такой таймер можно уничтожить с помощью
     tobj.destroy(); */
     #+END_SRC
** storage
     Предоставляет возможность сохранять объекты по ключу, обновлять их частями и извлекать только то, что
     нужно. По сути максимально простая db, архитектурно заточена под  репликацию. Версионная.
** http_requester
     Аналог xhr, но кросплатформенный
** http_responder
     Сильно упрощённый вариант web сервера, по api скорее похож на xhr
** ui
     набор модулей для формирования пользовательского интерфейса. Как и все остальный модули, главная задача
     ui быть кросплатформенным, это значит что используя один и тот же api вы можете написать приложение
     для web браузера или обычное desktop приложение. 
*** Compositer
       Основной модуль, реализующий логику ui элементов, способы работы с событиями и анимацию
       Концепция compositer очень проста, на ней основаны все иные ui элементы. Он оперирует следующими
       понятиями:
       + element
	 То чем манипулируют, то есть это элемент ui. В современной терминологии element может быть:
	 + window|surface
	   когда в него помещают другие элементы, он используется как холст
	 + widget|control
	   обычно это то же окно, но с содержимым, с которым пользователь взаимодействует
	 
         В общем случае element это прямоугольная область, над которой можно совершать манипуляции с помощью
	 animation и которая может получать события.
	 Все элементы с точки зрения animation и event одинаковы подобны простейшему element - frame
       + animation
	 Последовательность изменения свойств элемента. В анимации задаются цепочки изменения свойств и время,
	 за которое эти изменения должны наступить. Есть и способ немедленного изменения свойств, но animation
	 позволяет не только растянуть изменение свойств во времени(скажем реализовать плавное перемещение
	 элемента), но это также полноценный объект, который генерирует события(например анимация завершена)
         , которым можно управлять(к примеру остановить).
       + event
	 Все события обрабатываются единым образом. К элементам можно прикрепить обработчик того или иного 
	 события. Событиями зовётся всё, что происходит(клавиатурный ввод, движение курсора, завершение
	 анимации, какие-либо изменения элементов и тд)

**** Elements
     Общие свойства всех элементов, изменяемые общим образом через element_change_props или animation:
     + геометрические свойства
       Значения могут быть в %(рассчитываются относительно родителя) и в пикселях
       + x
         позиция элемента относительно родителя слева
       + y
       позиция сверху
       + width  
	 ширина элемента
       + height
	 высота элемента

     + прочие свойства
       + opacity
	 непрозрачность. Нулевое значение - полная прозрачность. Может быть указана в процентах или вещественным числом от 0 до 1
       + z_index
	 номер слоя, на котором расположен элемент в родителе. Позволяет накладывать один элемент на другой в рамках одного родителя. Значение от нуля до 255, чем выше число тем ближе к зрителю.
***** frame
      Прямоугольная область без какого-либо самостоятельного наполнения. Основная цель, быть поверхностью-контейнером для других элементов. В один фрейм можно добавить любое число других элементов
      + конструктор 
	frame(info)
      + методы
	+ destroy()
	  Уничтожает frame
        + add(child)
	  Добавить какой-либо элемент к фрейму.
        + remove(child)
	  Удалить элемент из родительского фрейма
***** image
      Содержит и отображает изображение, пока что поддерживается png и svg.
      + конструктор
	image(info)
	поле info.source должно содержать объект типа types/image
      + методы
	destroy(i)
	  Уничтожает image
***** text
      Содержит текст, пока документации не будет, потому что элемент претерпит существенные изменения.
***** button

***** entry
**** Animation
     В основу механизма анимации положен массив объектов следующего содержания:
     #+BEGIN_SRC js
       {
           duration : '200', //Время, за которое нужно произвести изменения. Значение в миллисекундах
           actions : { //в этом объекте могут быть любые свойства элемента(x, y, width, height, opacity, z_index и тд)
               x : 10 //значение прибавляется к текущему значения этого свойства элемента. При этом используется тот тип значения, который был изначально задан. То есть если значение задано было в процентах, то прибавляются проценты, если в пикселях, то прибавляются пиксели.
               y : -20 //значение отнимается от текущего значения этого свойства элемента.
           }
       }
     #+END_SRC
     Каждый элемент массива(то есть указанный выше объект) исполняется строго последовательно, начиная от 0.
     + коструктор
       anim(chain)
	 создаёт анимацию
	 chain - это массив объектов, как указано выше.
     + методы
       + destroy(id)
	 уничтожает анимацию
       + bind(element)
	 привязывает анимацию к определённому элементу. Одна и таже анимация может быть привязана к множеству элементов.
       + unbind(element)
	 Отвязывает от элемента анимацию.
       + start(element)
	 Начинает исполнение анимации
       + stop(element)
	 Прекращает исполнение анимации
	 
**** Events
     Обработчики событий устанавливаются подобно EventEmitter из nodejs, у каждого элемента есть:
     + метод on(event_name, callback)
       устанавливает callback. Чтобы убрать callback с какого-нибудь события нужно также вызвать .on, но не указывать последний аргмент - callback.
       + event_name
	 имя события, которое хотим отлавливать
       + callback
     + Виды событий
       События pointer значат любой указатель, не только мышь, но и пальцеtouch. Все эти события содержат один и тот же объект: массив объектов, где каждый элемент состоит из номер указателя, координат
       + pointer_in
	 указатель зашёл на элемент
       + pointer_out
	 указатель покинул элемент
       + pointer_down
	 на указатель нажали(например кнопка мыши или же tap)
       + pointer_up
	 указатель отжали(в случае touch также отрабатываются и pointer_down и pointer_up)
       + pointer_motion
	 движение указателя по элементу
       + key_down
	 нажатая клавиша клавиатуры
       + key_up
	 отжатая клавиша клавиатуры
       + animation_stopped
	 закончилась анимация над элементов, в качестве параметра указывается какая анимация.
 
       Также некоторые элементы имеют свои события, например от dnd_dest можно получать drag_leave, drag_motion и тд.
       Специфичные для конкретных елементов события описаны в документации к самим элементам
*** dnd
    реализация drag and drop для capsule. Помимо переносимости api, цель dnd модуля также в том, чтобы перетаскивались
    полноценные объекты, известные в capsule окружении. То есть переносятся не какие-то строки, конкретные
    объекты: ссылки, файлы и элементы Compositer. Это полностью скрывает реализацию и даёт возможность
    реализовать максимально эффективное API.
    Концепция основана на модификации любого элемента, используя dnd_source_activate или dnd_dest_activate.
    Модифицированный элемент умеет генерировать соответствующие события и получает новые методы

**** dnd_source
     Любой элемент может стать dnd_source с использованием модификатора: 
     dnd_source_activate(element)
     Затем он имеет:
     + события
       + drag
	 испускается, когда элемент начинают тащить
       + drag-motion
	 испускается переодически, во время движения элемента
       + drag-drop
	 испускается при сбрасывании элемента
       + drag-get_data
	 строго говоря не совсем событие, а запрос данных, происходит при успешном drag-drop

**** dnd_dest 
     Любой элемент может стать dnd_dest с использованием модификатора: 
     dnd_dest_activate(element)
     Затем он имеет:
     + drag-enter
       испускается при наезде перетаскиваемого элемента на dest.
     + drag-leave
       испускается, когда перетаскиваемый элемент покидает пределы dest
     + drag-motion
       испускается при движении перетаскиваемого элемента поверх dest
     + drag-data
       испускается когда данные при drop перетаскиваемого элемента над dest пришли.
     + drag_drop
       испусается при сбрасывании перетаскиваемого элемента на dest
    
*** filechooser
    элемент для запрашивания и обработки файлов от пользователя
       
    Результатом работы является файл или файлы как экземпляры types/file.
* for hacking
  
