* Черновик, попытка описания что есть capsule и как её использовать

** Первые шаги
   Для начала нужно получить себе версию capsule, проще всего просто воспользоваться git. Предполагается,
   что у вас есть какой-нибудь linux, где установлены или nodejs или gnome3.
   
   В общем клонируем:
   git clone https://github.com/ixdu/capsule

   Далее ради интереса заглядываем в папку examples и просто пошарившись там делаем какие-нибудь выводы о
   структуре проектов, которые используют capsule.
   Затем создаём свою папку, скажем tutproject, в корне capsule
   capsule/tutproject

   Затем было бы неплохо ещё раз залесть в examples и попытаться вникнуть в структуру того же player, ну
   да ладно.
   Любом проект использующий capsule состоит как минимум из 3х файлов:
   + config.json
     В нём указывается как минимум имя и местоположение первой функции, которая будут выполнена при запуске
     приложения. То есть в отличие от обычных js окружений нет какого-то главного файла, который выполняется
     типо как загружаемый html в браузер или файл, который вы указываете в качестве аргумента nodejs. 
     Здесь же чётко указывается какая функция в каком модуле выполняется при запуске.
     По умолчанию это capsulated.main. Это значит модуль capsulated, функция main.
     
     Далее можно указать дополнительные настройки, вроде
     + deploy_type - http|file. 
       + http означает приложение при разворачивании будет выставлено как web приложение
       с помощью web server. 
       + file же значит, что приложение будет упаковано в набор html и js файлов. 
       При этом сама настройка deploy_type специфична для web платформы на данный момент
     + deploy_url
       адрес, по которому будет выстановлено приложение, если был указан deploy_type как http

   + somefile.json
     любой файл, с расширением .json, только если это не config.json будет загружаться в алфавитной
     последовательности(типо как правла во всяких там init, udev и тд).
     Такие файлы имеют одинаковую структуру(тут самое время посмотреть её на примере 
     examples/player/04capsulated.json. Смысл этих файлов описать все файлы, которые используются в проекте
     и сформировать виртуальное дерево из этих файлов. То есть если у нас допустим есть модуль capsulated.js,
     то мы его можем с помощью способа формирования виртуального дерева представить его и как ./capsulated.js
     и как ./somefolder/lib/capsulated.js.
     На что это влияет? На использование этих модулей или ресурсов в проекте. То есть из примера выше мы бы
     подгружали уже в коде данный модуль либо как require('capsulated') либо как 
     require('somefolder/lib/capsulated').
     В виртуальное дерево упаковываются не только модули, но и другие ресурсы, например изображения.
     Затем в коде они подгружаются как модули:
     require('somefolder/someimage').
     О том как это просходит и благодаря чему, мы ещё поговорим. Пока лишь скажу, что все ресурсы подгружаются
     не низкоуровнево как мы привыкли(прочитал файл, распарсил его с помощью какой-либо либы, получил объект),
     а сразу как объекты. То есть подгружаемое таким образом изображение сразу можно добавить на канвас например
     или отправить куда-нибудь.

   + somefile.js
     Должен быть хотя бы один js файл и он должен быть описан в хотя бы одном из файлов, которые описаны в 
     предыдущем пункте. js файлы это модули в понимании commonjs. В общем это и есть ваш работающий код и
     если такой файл один, то в нём и располагается точка входа в приложение.

   Дальше копируем содержимое examples/skeleton к себе в папку проекта и получаем самый минимум того, с чем
   можно работать. Правда скорректиируем пути в 04capsulated.json, заменив examples/skeleton на наш tutproject.

   Затем переходим(для этого удобно хотя бы иметь ещё одну вкладку терминала) в 
   capsule/platforms/ваша платформа/deployer. Допустим у вас gnome3, тогда вы очутитесь здесь:
   capsule/platforms/gjs/deployer
   И собираем наш скетел:
   ./deployer gjs assemble tutproject
   И запускаем:
   ./deployer gjs run tutproject
   Если видим hello, значит всё прошло хорошо и мы готовы двигаться дальше.

** Разбираемся дальше, модули, ресурсы, как оформлять и кто на ком стоит, часть 1 
   Чтобы что-то написать, нужно хотя бы уметь использовать те возможности, которые предоставляет capsule.
   Эти возможности предоставляются с помощью модулей и встроенных типов. Эта же глава является введением в
   то, как использовать модули, ресурсы и чем они являются по своей сути.
   
   Итак, любой модуль это в любом случае .js файл. Да, могут быть исключения для различных платформ, где модули
   встроены, но это другой разговор. Подгружается модуль с помощью стандартного выражения  для commonjs 
   окружений: require(somepath) 
   Все модули, даже стандартные, формируют единое виртуальное дерево модулей с помощью единого механизма,
   который является частью капсулизации(процесса сборки приложения и всех его зависимостей в пакет). Частью
   это процесса является конфиг сборки - файл с расширеним .json, подобно тому что был предыдущей главе под 
   именем somefile.json. Его более реальную версию можно глянуть в examples/player/04capsulated.json.
   О структуре этого файла подобробно будет описано в следующей главе, пока лишь важно понимать именно с 
   помощью таких файлов(явно или неявно) описывается из каких модулей и ресурсов будет состоять ваше 
   приложение. Это касается как написанных вами частей, так и встроенных модулей. При необходимости, в 
   готовое приложение можно будет собрать только те модули, которые вы используете.

   Ну если с модулями всем, кто писал на js всё более-менее понятно, то что есть ресурс? Ресурс в понимании
   capsule это некоторая порция данных, для которых есть встроенный тип. Например ресурсом может быть
   изображение. В таком случае вы добавляете это изображение в конфиг сборки, допустим таким образом:
   #+BEGIN_SRC javascript
   "images" : {
       "type" : "image",

       "blue" : "tutproject/images/blue.png"
   }
   #+END_SRC
   В результате, blue.png упакуется в приложение вместе с основным кодом и будет доступно для использования
   внутри него с помощью:
   #+BEGIN_SRC javascript
   var blue = require('images/blue')
   #+END_SRC
   Как это происходит, и что возвращает require? Как точно изображение упакуется в приложение зависит от
   платформы, скажем для web и для gjs(на данный момент) - изображение упаковывается в base64, а затем в 
   модуль. То есть данные изображения упаковываются в модуль, при подгрузки которого данные изображения 
   передаются реализации встроенного типа - в нашем случае это будет types/image. На выходе мы получаем
   объект types/image, который уже готов к применению в любом модуле capsule.
   Это значит, что можно сделать так:
   #+BEGIN_SRC javascript
   comp.frame_add(frame1, comp.image_create({source : blue}));
   #+END_SRC
   и если frame1 это допустим область в середине экрана, то мы получим синию точку в этой области.
   
   Зачем такие сложности, если можно взять, прочитать файл, распарсить его с помощью нужного модуля и
   использовать? Ну потому что никаких файлов у капсулированного приложения нет, только виртуальное дерево.
   К тому же, так удобнее. То же comp.image_create это устаревший метод, который в будущем будет не нужен и
   c image сразу можно будет работать на канвасе. То есть ресурсы сокращают объём кода и делают работу с
   данными проще. Ко всему прочему разные платформы могут по разному работать с данными, и то что в конечном
   счёте называется типом может быть реализованно совсем по разному. В общем без типов, работа с данными
   была бы несколько разной для разных платформ, а это нам не нужно:)

** Встроенные модули
   Собственно это то, что вы скорее всего будете использовать очень часто чтобы ваше приложение хоть как-то
   взаимодействовало с внешним миром. 
   Единственно, что здесь нужно сказать заранее. capsule не пытается быть фреймворком, могущим всё
   (вроде той же java). В capsule есть только те модули, которые кому-нибудь понадобились(и были реализованны
   теми, кому они понадобились:)) 
   Что это значит на практике? Ну например вы можете столкнуться с тем, что привычные вам и доступные
   вещи в какой-нибудь java(скажем библиотека для доступа к nfc) могут здесь отсутствовать напрочь. Да что
   там nfc, в capsule сейчас проще сказать что есть(а это всего парочка api), чем перечислять чего нет.
   
   Самое время для пары примеров кода. 
   Пример с time:
   #+BEGIN_SRC javascript
   var timer = require('modules/timer');
   timeout = timer.create(function(){
                                        console.log('tick once');
                                    }, 100, false);
   interval = timer.create(function(){
                                        console.log('tick each 200 millisec
                                     }, 200, true);
				     
   #+END_SRC
   Первый вызов create создаёт одноразовое срабатывание таймера, потому что последний аргумент cyclic 
   установлен в false. Второй вызов создаёт срабатывание каждые 200 миллисекунд.

   Пример с Compositer:
   #+BEGIN_SRC javascript
   var comp = require('modules/ui/Compositer').create(), 
   //загружаем модуль и создаём экземляр Compositer, что аналогично созданию окна
       center_area = comp.frame_create({
                                           x : '30%',
					   y : '30%',
					   width : '40%',
					   height : '40%'
                                       },
       // создаём фрейм, который будет располагаться по середине и будет иметь размер в 40% от окна 
       image = comp.image_create( {
                                      width : '100%',
				      height : '100%,
				      source : require('images/blue.png')
                                  };
       // создаём изображение, котороё займёт всю поверхность созданного до этого фрейма.
       // Изображение подгружается как модуль, об этом уже рассказывалось в предыдущей главе, а это
       // просто реально работающая демонстрация
   comp.frame_add(0, center_area);
   //фрейм, который располагается по центру наносится на root фрейм, он же окно, он же 0
   comp.frame_add(center_area, image);
   //изображение наносится на к center_area
   #+END_SRC
** Пишем что-нибудь работающее с ui

** Конфиги сборки
   Написание любого приложения, состоящего из хотя бы 2х файлов невозможно без конфигов сборки. Цель таких
   конфигов описать какие файлы используются в приложении и по каким путям они будут доступны в самом коде.
   То есть с помощью конфигов сборки все файлы приложения выстраиваются в виртуальное дерево, подобное
   fs. За полным описанием формата конфигов обращайтесь к разделу api, здесь будет даны конкретные 
   практические примеры использования.

*** Ещё несколько файлов в проекте
   Допустим мы захотели выделить в отдельный файл часто используемые в проекте объекты. Ну и конечно добавить
   пару изображений для использования, куда же без них. Значит наш итоговый конфиг будет выглядеть примерно
   так:
   #+BEGIN_SRC javascript
   {
       "type" : "module",

       "preload" : true,
       "inline" : true,

       "images" : {
 	   "type" : "image",
	
	   "blue" : "examples/skeleton/images/blue.png",
	   "red" : "examples/skeleton/images/red.png"
       },
       "newimages" : {
           "type" : "image",

	   "round" : "examples/skeleton/images/round.svg",
	   "cursor" : "examples/skeleton/images/cursor.svg"
       },
       "commonlib" : "examples/skeleton/commonlib.js",
       "capsulated" : "examples/skeleton/capsulated.js"
   }  
   #+END_SRC
   А теперь разберём написанное.
   Поле type указывает на то, какого типа файлы будут загружены. Доступны всего несколько вариантов:
   + module
   + text
   + image
   + audio
   + video
   
   Все типы работают через концепцию types капсулы. Не буду разъяснять что это значит. Главное то, что
   все файлы таким образом стают полноценными объектами, с которым вы сразу можете работать в коде. То есть
   вы подгружаете не файлы, а объекты.

   На preload и inline не обращайте внимания, главное пока не разберётесь всегда указывайте их в true. Эти
   флаги нужны для специфической сборки под некоторые платформы(web).

   Далее мы добавили новую папку newimages, в то время как файлы в ней содержащиеся берутся из обычной папки
   images на fs. Это важный момент, мы конструируем виртуальное дерево, а не отражаем структуру fs. Тут ничего
   нового нет, кроме того что изображения типа svg.

   Ну и конечно commonlib. Добавлен как и capsulated, ничего нового. Теперь кратко о том, как использовать
   добавленное нами в коде.

   #+BEGIN_SRC javascript
   var round = require('newimages/round'),
       cursor = require('newimages/cursor'),
       commonlib = require('commonlib');
   #+END_SRC

   Ну и в завершении о модулях. Они оформляются в формате commonjs. Подобробно о нём можно найти на просторах
   интернета. Вот пример модуля commonlib:
   #+BEGIN_SRC javascript
   function private_print(printer, message){
    console.log(printer, message);
   }

   exports.printer_one = function(message){
       private_print('one is printed:', message);
   }

   exports.printer_two = function(message){
       private_print('two is printed:', message);
   }
   #+END_SRC
   Затем модуль используется так:
   #+BEGIN_SRC javascript
   commonlib.printer_one('hello tutor');
   commonlib.printer_two('hello tutor');
   #+END_SRC
   В результате будет напечатано:
   one is printed: hello tutor
   two is printed: hello tutor

   При этом использовать можно только те функции, которые присвоены с помощью объекта exports.
   private_print не будет видна за пределами файла, то есть нельзя её использовать через 
   #+BEGIN_SRC javascript 
   commonlib.private_print
   #+END_SRC

   Ещё один способ опубликовать функции модуля, это присвоить сразу объект, например так:
   #+BEGIN_SRC javascript
   modules.exports = {
       printer_one : function(message){
           private_print('one is printed:', message);
       },
       printer_two : function(message){
           private_print('two is printed:', message);
       }
   }
   #+END_SRC
   Делает тоже, что и пример выше но позволяет присваивать сразу объект. Иногда удобно:)
   
** Ну в заключении о том, во что и как собирается ваше приложение
*** Во что собирается приложение и как
   Как писать код, связывать его воедино с ресурсами с помощью конфигов сборки вы уже разобрались. Но надо
   понять, что для работающего приложения его нужно собрать. Это уже было в первой главе, в этой же главе
   будут в основном пояснениия.
   Код приложения собирается с помощью deployer, но в зависимости от платформы результат сборки может сильно
   отличаться:
   + для веб браузера это будет всего несколько файлов: capsule.html и constructor.js.
   + для nodejs это будет целая папка файлов, которые расположатся в ней и сформируют реальное fs отражение
     того виртуального дерева, которое было описано в конфиге сборки. Иными словами файлы будут файлами и
     пути будут реальны.
   Это всего два примера. Для других платформ отличия могут быть ещё сильнее. Скажем под тот же андроид(хотя
   никакой поддержки android пока нет) все файлы ещё будут засунуты в установочный пакет.
   Также сильно может отличаться то, как упаковываются ресурсы. Те же изображения могут хранится как модули
   в виде текста, преобразованные с помощью base64, а могут и как обычные файлы или один файл.
   Что это значит? Что нельзя полагаться ни на какие механизмы, которые не предлагаются capsule _явно_. 
   Например: capsule предоставляет возможность работы с файлами, но нельзя с помощью этих возможностей читать
   ресурсы. Да это может сработать на тех платформах, где ресурсы хранятся в файлах, но на других приведёт к 
   ошибкам.

   В общем придерживайтесь правила _всегда делать всё явно с помощью capsule api_. Никакие хаки потипу тех,
   что являются нормой для веб программистов, использующих какой-нибудь jQuery, здесь неуместны.
   В api и hacking вы узнаете, что стиль веб программистов вполне уместен в платформо-образующих модулях,
   но этот tutorial не об этом:)

*** Как собирается и что такое deployer
**** кто такой, что делает
    deployer, это что-то вроде ассемблера, линкера и архиватора в одном лице. В общем он берёт ваши файлы
    и делает готовое для выполнения приложение на конкретной платформе.
    В общем виде его использование выглядит так:
    ```deployer платформа команда путь_к_проекту_от_корня_capsule```
    + платформа
      На данный момент реально поддерживаются nodejs, gjs, web
    + команда
      + assemble
	собрать проект, самая ёмкая по времени операция. На этом этапе обрабатываются все конфиги и файлы,
	собираются воедино
      + deploy
	сильно зависит от платформы, может даже отсутствовать, потому что после assemble получается готовый
	к применению образ. В основном нужен для платформ, где требуется собранный пакет(android например)
	или просто специальная подготовка(для web платформы предусмотрено два способа развёртывания: просто
	записать в файлы, которые можно скопировать или запустить web server и раздать по определённому
	адресу)
      + run
	Запустить значит запустить, стартует собранный проект. Как правило платформы у которых есть run не
	имеют deploy(gjs, nodejs и тд)

**** как работает, устроен
     Это конечно не hacking раздел, а значит в подробности вдаваться не буду. Но самая главная информация
     для прикладных разработчиков следующая:
     + по сути это отдельный проект, готовое приложение никак от него не зависит. Этакий компилятор в
       составе capsule.
     + он использует модули из capsule/platforms для своей работы. А значит он работает там, где работает
       capsulе. Это важный момент, когда мы говорим что capsule поддерживает ту или иную платформу, мы
       говорим, что она её поддерживает и как host(deployer) и как target(capsulated application)

	
