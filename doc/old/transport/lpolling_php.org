* Concept transport's(ajax, SCRIPT) php server side 

  Реализация серверной стороны, асинхронного коллектора запросов, с гарантией реально-временной обработки запросов(тут надо отметить что real-time понимается скорее в смысле
  что нет задержек при получении запроса или отправке запроса(которые есть в обычном ajax или long pooling, основанном на таймаутах), а не всмысле гарантий обработки запроса
  в заранее определённый промежутов времени)
  
** Окружение

   В принципе это мало относится конкретно к php, тоже самое можно сделать и на perl или любом другом языке.
  
   В рамках этой писанины предполагается, что http клиент посылает запросы http серверу и на каждый запрос порождается экземпляр обработчика(скрипт, работающий в отдельном процессе или потоке). 
   Таким образом два запроса могут обрабатываться независимо друг от друга, параллельно, и нет заранее предопределённых способов взаимодействия c обработчиком.
   
** Цель
   
   Сформировать из сообщений, приходящих параллельно - очередь сообщений, которая будет направляться одному обработчику, получающему сообщения последовательно. Который, однако, может обрабатывать
   их в любом порядке. То есть получив сообщение, может ответить на него спустя долгое время.
   Сообщение  - это сообщение в терминах capsule.module.transport.
   Также это значит, что для возможности ответа на сообщения без задержки, необходимо реализовать long-pooling технику, с запросами на упреждение.

** Средства:
   Обычно это apache + mod_php. Может быть с форком на запрос, может с отдельным потоком на запрос - не важно.
   Также возможен вариант http server + fastcgi + php. Никакой привязки к средствам http браузера нет. Только средства php.
   Определимся с понятиями:
   + http_server
     сервер http, возможно apache, возможно что угодно, пусть даже ligthhttp с fastcgi
   + http_client
     браузер, возможно просто какое-то приложение, написанное на node.js, flash, не суть. Главное, оно должно уметь работать в соответствии с протоколом передачи сообщений
   + lp_worker
     long pooling
     экземпляр php, который непосредственно обрабатывает http запрос. Он может быть один, но скорее всего их будет много, так как порождается по экземпляру на запрос.
     Может удерживать соединение с http_client максимально долго.
   + queue_collector
     Собирает все сообщения от lp_worker'ов и отправляет им ответы. В теории, их тоже может быть много:D
   + proto_frame
     Запроc, посылаемый от http_client к http_server. Может содержать всё сообщение, часть сообщение или же быть пустым, для реализации lp.
   + php_capsule
     Некотороый аналог capsule настоящей, но на php

     От php нам нужно:
   + max_execution_time
     Для того, чтобы реализовать не аварийную, а предсказуемую остановку обработчика очереди сообщений по таймеру, заранее, до истечения времени
   + sockets
     Для взаимодействия между lp_worker и queue_collector
   + да вроде всё:)
	
** Пример

   Предположим нам нужно отправить 3 сообщения с http_client
   На первые два ответить с php_capsule по 2 сообщения
   На 3е ответить 5 сообщений
   И ещё послать с php_capcule 2а сообщения
   Итого в общем у нас будет 5ть id - от 1 до 6
   3 из них использованы http_client
   2 из них - php capsule
   

*** Разложим всё это на js код

```javascript   
//http_client code

cli_trans.send(1, 'hello one', function(msg_id, msg_body){
 /*отпработает два раза и отпечает
 * hello one hello back
 * hello one hello back
 */
});
cli_trans.send(2, 'hello two', function(msg_id, msg_body){
 /*отпработает два раза и отвечает
 * hello two hello back
 * hello two hello back
 */
});
cli_trans.send(3, 'hello three', function(msg_id, msg_body){
 /*отпработает пять раз и отвечает
 * hello three hello back
 * hello three hello back
 * hello three hello back
 * hello three hello back
 * hello three hello back
 */
});


php_capsule code

serv_trans.send(4, 'hello from capsule one'), '');
serv_trans.send(5, 'hello from capsule two'), '');

serv_trans.on('message', 0, function(msg_id, msg_body){
    if(msg_id < 3){
        serv_trans.send(msg_id, msg_body + " hello back", '');
        serv_trans.send(msg_id, msg_body + " hello back", '');
    } else if(msg_id == 3){
        serv_trans.send(msg_id, msg_body + " hello back", '');
        serv_trans.send(msg_id, msg_body + " hello back", '');
    }
}
```

Код со стороны капсулы написан на js, но это так, это скорее всё псевдокод:)
Всё просто, пояснять особо нечего.

*** Теперь переложим всё это на наш слоёный пирог по шагам.

Для начала определим протокол взаимодействия http_client и lp_worker.
Обмен между http_client и lp_worker идёт посредством proto_frame. Его примерный вид:
```javascript
proto_frame = {
 sid,
 m : [
{
 id, //message id
 tm, // track me
 p, //message parts
 pn, //message part number
 d, //message data
}]
}
```

+ stream_id - uuid потока сообщений. Клиент, желая сохранять поток(то есть возможность принимать ответы на посланные сообщения), должен посылать stream_id
хотя бы раз в некоторый промежуток времени(пока что 10 секунд). Если за 10 секунд не было послано хотя бы пустого фрейма с stream_id, то router может удалить всю информацию
о messages, принадлежащих этому потоку. По сути stream_id это идентификатор логического, двустороннего потока сообщений, соединения точка точка.

+ m - это массив из объектов, каждый объект следующего вида:

  + id 
    id сообщения, всегда есть, если посылается часть или полное сообщение
  + p - количество частей в сообщении. Есть, если сообщение передаётся по частям
  + pn - номер части, если передаётся по частям. Есть, когда передаётся сообщение по частям
  + d - данные сообщения. Часть или всё сообщения. Есть, когда передаётся сообщение

Обмен c proto_frame идёт и в сторону http_server и в сторону http_client. Однако в подавляюещем
большинстве случаев, в сторону http_client не будут передаваться сообщения по частям.

[[lphp_stream_id][описание stream_id]]

Итак, возвращаемся к нашему примеру js кода. Остановимся пока только на отсыле сообщения 1 и двум ответам на него:)
Также предположим, что каждое сообщение передаётся в двух фреймах со стороны http_client.
Получаем два AJAX запроса:

```javascript
req1_p1_proto_frame = {
 sid : 12,
 m : [
  {
   id : 1,
   p : 2,
   pn : 1,
   d : "hello"
  }
 ]
}

req1_p2_proto_frame = {
 sid : 12,
 m : [
  {
   id : 1,
   p : 2,
   pn : 2,
   d : " one"
  }
 ] 
}
```
и два ответа : 

```javascript
rep1_proto_frame = {
 sid : 12,
 m : [
  {
   id : 1,
   d : "hello one hello back"
  }
 ]
}

rep2_proto_frame = {
 sid : 12,
 m : [
  {
   id : 1,
   p : 2,
   pn : 2,
   d : "hello one hello back" 
  }
 ]
}
```

**** Реализация php стороны
Теперь о том, куда эти запросы уходят и как формируются ответы.

+ раз
  Запросы идут к http_server и попадают в php. Либо для каждого запроса создаётся по экземпляру php, либо один экземпляр обрабатывает два запроса. 
+ два
  После того, как req1_p1 приходит к lp_worker, lp_worker пытается найти unix socket от queue_collector, допустим с именем qc.sock. И если не находит,
то сам создаёт в себе объект queue_collector и создаёт такой сокет.
+ три
  затем пытается прочитать qc.state файл, если получается - блокирует его.
+ четыре
  подгружает из него предыдущее состояние queue_collector, которое было сериализовано и записано туда. 
+ пять
  lp_worker устанавливает таймер, на пару секунд меньше, чем max_execution_time. Если max_execution_time не определён, или слишком длинный(FIXME выработать критерии длинности),
  то устанавливается таймер в неболее, чем пару минут.
+ шесть
объединяет таймер и сокет в набор, для использования в select и засыпает, вызывая select
+ семь
  на req1_p2 http_server порождает ещё один lp_worker, который действует, как описано выше, но на шаге два, соединяется с qc.sock и посылает сообщение туда.
+ восемь
  qc получает сообщение, находит у себя в объектахъ p1, объединяет с p2, и вызывает каллбек, который был определён для отлова сообщения с id 1
+ девять
  qc, зная что этот lp_worker один, кто соединяет его и клиента, посылает lp_worker сообщение wait, принуждающее последнего держать запрос максимально долго(техника lp).
  Тут надо заметить, что если lp_worker таки умрёт(например соединение клиент-сервер оборвалось), то qc получит также обрыв соединения unix сокета с lp_worker.
+ десять
  каллбек в qc посылает сообщение ответ - "hello one hello back", которое отдаётся lp_worker, который доставляет это сообщение в своём ответе.
  Тут надо заметить, что qc может послать lp_worker множество сообщений, чтобы тот доставил их в своём ответе. Но qc должен закончить маркером send_now явно, если он
  это не сделает, то lp_worker ждёт этого маркера и не отправляет ответ.
+ одинадцать
  qc получает событие таймера, сохраняет всё своё состояние(включая объекты, удерживающие части сообщений, каллбэки и тд) в qc.state файл, затем уничтожает слушающий
  unix socket и завершает свою работу.

Описанные шаги могут повторяться многократно.

+ Отдельное замечание про флаги wait, send_now и тд
  То как они передаются не имеет значения, также не определено здесь как передаются сообщения через сокеты, в зависимости от реализации это может быть простейший json протокол,
  а может быть и какой-то бинарный протокол, кто его знает:)


