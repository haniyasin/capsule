* Stream id
  Из-за того, что постоянное соединение не поддерживается, а точнее не может гарантироваться, необходим механизм, который всё таки даёт возможности, подобные
  постоянному соединению. Иначе было невозможно отправлять ответы на сообщения в любой момент времени, так как неизвестно кому отправлять. Для решения этой проблемы
  клиент и сервер создают логический поток, присваивая ему stream_id. Клиент отсылает stream_id в каждом своём запросе. Попадая в lp_worker этот stream_id доходит до 
  queue_worker и далее сохраняется им, привязывая к stream_id - message_id, которые принадлежат этому потоку(принадлежность предназначения для маршрутизации и чистки мусора, 
  сами же message_id всех клиентов уникальны относительно друг друга. Каждые 10 секунд queue_worker проверяет срок годности всех
  своих stream_id и если находит старого(более 10 секунд не обновлявшегося), то удаляет всю принадлежащую этому stream_id информацию для маршрутизации.
  dealer и router предполагают, что к router могут подключиться сразу множество dealer. При этом все сообщения от всех dealer будут идти общим потоком, так как transport 
  не предполагает механизмов аналогичных сокетовому accept. На каждое сообщение может быть ответ, а значит router должен хранить информацию обо всех когда-либо проходивших через
  него сообщениях. История легко зачищается если речь идёт о постоянных соединениях типа tcp, там обрыв соединения означает зачистку всех сообщений, связанных с соединением.
  Поскольку ничего подобного невозможно с непостоянным соединением типа AJAX, то и необходим аналогичный механизм, которым и является stream_id.  
  router просто привязывает каждое message_id к тому stream_id, из которого пришло сообщение. И убирает привязанные message_id, когда уничтожается stream_id.
