* Структура capsule(или кто на ком стоит и за что отвечает)
  Что такое capsule? В общем - это набор модулей, представляющих некоторый API и конфигуратор(deployer),
  который из этих модулей собирает конфигурацию, которая будет работать в конкретном окружении.
  Состоит из следующих частей:

** deployer
   На основе конфигов и имени платформы для которой происходит сборка создаёт образ. Также отвечает за запуск
   и/или развёртывание этого образа.
   Конфиги определяют какие модули нужно добавить в образ, в каком порядке и какую структуру из них 
   сформировать.
   Его работа делится на:
   + определение файлов, которые необходимо добавить в образ на основании конфигов
   + формирование базового образа, включающего в себя специфические особенности характерные для выбранной
     платформы(например в браузере и gjs нет require, поэтому в их образы добавляется реализация require
     в виде module_loader).
   + добавление в образ файлов, которые были определены на первом этапе. Способ добавления сильно зависит
     от платформы, для который происходит сборка. Для nodejs все файлы помещаются в папки со структурой,
     подобной той, в которой они раньше располагались в capusle tree, а потом просто подгружаются с помощью
     require. Для браузера, gjs и иных платформ, не поддерживающих require, файлы упаковываются прямо в файл
     образа и добавляются в module_loader. В случае того же gjs формируется вообще один единственный файл,
     в который упаковывается весь образ со всеми зависимостями.
     Но одно для всех платформ неизменно - все модули, которые подгружаются на основе конфигов, формируют
     единое дерево, которое одинаково на любой платформе. Естественно это может быть и не так, если вы
     создаёте разные конфиги для разных платформ, но это вариант особенный.
     Иными словами если вы напишете в коде:
     var transport = require('modules/transport/direct.js')
     то на всех платформах результат будет тот же.
     Это одна сторона того, что я называю единым API - единое дерево для всех поддерживаемых платформ.
   
   Deployer состоит из двух частей:
   + общая для всех платформ, делающая работу, которая едина для всех платформ, включая разбор конфигов
   + конкретная для каждой платформы. Из-за того, что каждая платформа сильно отличается, это учитывается
     используя специфические deployer. Они учитывают специфику, генерируют в соответствии с тем что нужно.
     Это уже упоминалось выше. Некоторые значительно сложнее других, потому как вынуждены делать работу,
     которую в ином случае платформа может делать сама(например require)

*** структура конфигов и места их размещения
    Все конфиги помещаются в папку, которая является главной папкой образа и указывается в качестве
    аргумента в комманде:
        deployer.js platform assemble ourfolder
    Где ourfolder и есть эта папка, а
    platform одна из поддерживаемых платформ:
    + browser
    + nodejs
    + gjs

    конфиги просто размещаются в алфавитном порядке в этой папке и имеют расширение json, deployer это 
    распознаёт и подгружает их в _алфавитном_ порядке. Это значит, что для правильной последовательности
    конфигов необходимо использовать префиксы 01,02 или любые другие, соблюдающие алфавитный порядок.
    Все конфиги описывают единую иерархическую структуру, это значит, что если в одном файле есть:
    {
        "capsule" : {
            "dependencies" : {
                "base32" : "dependencies/base32.js"
            }
        }
    }
    а в другом
    {
        "capsule" : {
	    "dependencies" : {
	        "serializer" : "dependencies/json.js"
            }
        }
    }

    то оба они сформируют иерархию аналог файловой системы:
    capsule - folder
      dependencies -folder
        base32 - module
        serializer - module
	
    И хотя на данный момент уже не важно в каком порядке конфиги подгружаются, ведь они всё равно формируют
    единое дерево, это может иметь значение в дальнейшем. Тем не менее первыми грузятся конфиги capsule, 
    затем все остальные(dsa или sphere или иные).
    В одном из конфигов также должен быть описан файл, с которого начинается исполнение.
    А точка входа в этот файл указывается в config.json в виде entry
    !!!!!!!FIXME дальше необходимо описать формат конфигов
    ***
** modules
   Они формируют вторую сторону единого API, то есть они и есть это самое api.
   Существует два вида модулей:
   + modules
     независимые от платформ, как правило надстройки, формирующие capsule API
   + platforms/someplatform/modules
     Это модули, которые реализуются используя возможности конкретной платформы. Эти модули также формируют
     API. Многие api невозможно реализовать без взаимодействия с платформой напрямую. Простой пример: http
     request, он выполняется по разному в browser, nodejs или gjs. Поэтому для каждой платформы должна быть
     реализация некоторого API, которое уже потом будет использоваться независимыми от платформы модулями
     Данные модули также называются lowlevel, так как напрямую либо не используются(только через надстройки),
     либо используются, но с явными оговорками, как например deployer использует fs.
   
   Пока что окончательного списка модулей не существует, да и вряд ли будет существовать. Модули реализуются
   по мере надобности тех или иных возможностей. А API разрабатывается с учётом следующих главных акцентов:
   + переностимость
     API должно быть таковым, чтобы реализацию его можно было бы сделать для большинства платформ, иначе оно
     бесполезно и не может существовать. Многие фреймворки имеют разную степень возможностей под разными
     платформами, с capsule дела обстоят не так. Иметь _равные_ возможности на всех поддерживаемых платформах
     для нас приоритет. Нет смысла поддерживать платформу просто для галочки, от этого нет проку. Исключение
     составляют те случаи, когда те или иные API просто невозможно реализовать для той или иной платформы
     потому, что она не предоставляет таких возможностей(например отсутсвие устройств ввода).
     Правда отдельно стоит сказать про platforms/modules, теоретически, их может быть разное количество
     для разных платформ. Но тем не менее, широкое использование модулей, которые есть на одних платформах
     и отсутсвуют на других осуждается. Исключения могут быть, если это необходимо, допустим deployer, 
     который и не обязан работать на всех платформах.

   + асинхронность
     API должно быть асинхронным, потому как это приоритет для capsule, быть асинхронной. Все хоть 
     сколько-нибудь требующие времени операции должн быть асинхронными.

   + простота
     Многие API хорошо сделаны и даже эффективны, но их использование затруднительно и требует глубокого
     изучения. capsule, как и проекты на ней основанные, проповедует идею простоты, пусть даже ценой
     некоторой эффективности и непрофессиональности. Низкий порог вхождения гораздо важнее. Но мне кажется,
     что простые вещи они ещё и эффективны, ведь их легче обслуживать.
** parts
   Различные библиотеки, которые используются модулями. В принципе они также, как и модули могут быть
   использованны в проектах. Но как правило они просто являются зависимостями модулей, некоторыми общими
   частями, которые имеет смысл поддерживать отдельно.
** dependencies
   Тоже, что и parts, но сюда помещаются сторонние проекты, которые используются capsule, чтобы не изобретать 
   велосипеды. Выдели их отдельно важно и по лицензионным соображениям.
** platforms
   Содержит поддержку всех платформ.
   Для каждой платформы реализуется свой deployer и необходимый набор модулей. При необходимости, папка
   любой платформы может повторять структуру главной папки capsule, то есть то, что описывается здесь и выше.
   Может содежать modules, parts, dependencies и тд.
   В худшем случае, платформа может перереализовать все api сама.
** tests
   Содержит тесты для:
   + deployer
     содержит конкретные конфигурации, на которых можно проверить deployer каждой платформы и посмотреть
     результат.
   + modules
     Это тесты capsule API в виде тестов для конкретных модулей. Собранные вместе с deployer тестами они
     являются основными тестами для всех платформ. Так проверяется работоспособность тех или иных API
     на разных платформах, с помощью одних и тех же тестов.
