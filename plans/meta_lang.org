* Ещё один язык программирования. Причины
  Конечно же в мире мало языков программирования, это я понимаю:) Надо придумать ещё один, но если серьзно
  то зачем? Вот следующие причины, они же killer features языка(Впрочем возможно, что я просто не нашёл
  язык, который всё это может, но он есть:D):
  - быть простым в своей основе, но выразительным и компилируемым.
    Например Ocaml вполне подходит под описание. Его type inference и строгая типизация с коммандами для
    каждого типа это хороший подход. Но всякие вещи типа class уже встроены в язык как-то с боку, заплатами.
    Javascript тоже подходит, но почти, потому что type inference сделать не получится полностью без 
    ограничений.

  - self-hosting and fast bootstrap.
    Смысл в том, чтобы реализация(и язык тоже) была и компактной и быстрой. Чтобы развёртывание в любой 
    среде не представляло сложности. Например:
    - возможность компилировать прямо в браузере
    - возможность компилировать на любой платформе как обычный язык(допустим windows или linux)
    C большинством существующих языков есть в этом смысле проблемы - не в одном так в другом. Тотже haxe
    может компилироваться под кучу языков и платформ, но только с работающей реализации ocaml, для которой
    конечно есть бэкенд под js. Но в итоге, если попытаться компилировать сам haxe в браузере, потребуется
    куча усилий, тянуть зависимости и работать это будет неэффективно.
    В общем мало кто пытается заставить работать сам компилятор на всех target этого компилятора.
  
  - самомодифицируемость.
    В качестве название используется meta не просто так, хотя может это и не правильно использовать такое
    название. Смысл в том, чтобы было возможно вводить и выводить конструкции в и из языка. Это необходимо как
    для создания удобного доступа к высокоуровневыми вещам, так и к низкоуровневым. Появляется 
    возможность убрать низкоуровневые возможности, когда в них нет нужны или добавить высокоуровневые. Иными
    словами то, что мы обычно привыкли представлять как библиотеки с тем или иным интерфейсом(ООП, модульно-
    процедурным и тд) будет возможно интегрировать прямо в язык ровно так, как это было бы удобно и логично.
    Вот пара примеров:

    var array = int.alloc(4);
    array[2] = 15;

    Достаточно низкоуровнево, и может отсутствовать. Вместо этого может присутствовать такая конструкция
    var array = [0,15,0,0]
    
    А может и такая:
    var array = array(4) int;
    var array[2] = 15;

    Или такая:

    int[4] array
    array[2] = 15

    Ну и ещё пример:

    Вариант в стиле javascript
    let boy = { hello : function(string){
                            print(string)
                        }
              }

    Может быть такой вариант:
    
    object boy {
        method hello with string {
            print string
        }
    }

  - кодогенерация
    В самом простом случае это аналог eval. То есть компилятор как бы подшивается к программе и всегда
    готов к использованию внутри программы. При этом я уже говорил, что реализация языка должна быть простой
    и компактной, это крайне важно. Без этого подшиваемый компилятор будет крайне тяжёл и в итоге все 
    преимущества просто испарятся. Тут уместно сравнить с capsule, которая также компактна и не может быть
    раздута - иначе любое вебприложение, использующиее эти технологии, будет только загружаться полчаса.
    И хотя eval вринципе достаточен, надо подумать как реализовать приемлемый вариант с учётом возможностей
    самомодификации языка.

  Зачем всё это? В основном для двух целей.
  - скрыть все внутренности sphere, dsa, capsule. Сделать работу с ними более естественной. К примеру было
    бы неплохо писать как-то так:
    card 'example'
    click {
        label 'ok'
    }
    вместо
    var example = new card('example', stack);
    if(example.old)
        return;
    new click({ label : 'ok'}, stack);
    Как видно скрывается и явное использование stack и необходимость явного возврата, если card уже 
    существует. Много ручной работы, которую нет смысла делать каждый раз. Это примерно как вместо 
    использования new написать собственную function new_object() и делать кучу связанных с созданием
    объекта вещей вручную. Можно, но неудобно. И чем больше сущность, тем больше подробностей. Необходимо
    абстрагироваться, естественно на уровне языка. Это делает код компактным и понятным. В общем DSL:)

  - эффективно работать на разных платформах.
    Для dsa, sphere, capsule нужен максимум эффективности(скорость, память и тд) среди тех условий, где происходит исполнение.
    Сейчас подобное даёт C или С++, их можно компилировать даже в javascript. Но у них, как и множества их
    альтернатив, просто жутко тяжёлые компиляторы и runtime. Ну и полностью отсутствует meta способности.
* описание

* Примеры
