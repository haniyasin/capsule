* Ещё один язык программирования. Причины
  Конечно же в мире мало языков программирования, это я понимаю:) Надо придумать ещё один, но если серьзно
  то зачем? Вот следующие причины, они же killer features языка(Впрочем возможно, что я просто не нашёл
  язык, который всё это может, но он есть:D):
  - быть простым в своей основе, но выразительным и компилируемым.
    Например Ocaml вполне подходит под описание. Его type inference и строгая типизация с коммандами для
    каждого типа это хороший подход. Но всякие вещи типа class уже встроены в язык как-то с боку, заплатами.
    Javascript тоже подходит, но почти, потому что type inference сделать не получится полностью без 
    ограничений.

  - self-hosting and fast bootstrap.
    Смысл в том, чтобы реализация(и язык тоже) была и компактной и быстрой. Чтобы развёртывание в любой 
    среде не представляло сложности. Например:
    - возможность компилировать прямо в браузере
    - возможность компилировать на любой платформе как обычный язык(допустим windows или linux)
    C большинством существующих языков есть в этом смысле проблемы - не в одном так в другом. Тотже haxe
    может компилироваться под кучу языков и платформ, но только с работающей реализации ocaml, для которой
    конечно есть бэкенд под js. Но в итоге, если попытаться компилировать сам haxe в браузере, потребуется
    куча усилий, тянуть зависимости и работать это будет неэффективно.
    В общем мало кто пытается заставить работать сам компилятор на всех target этого компилятора.
  
  - самомодифицируемость.
    В качестве название используется meta не просто так, хотя может это и не правильно использовать такое
    название. Смысл в том, чтобы было возможно вводить и выводить конструкции в и из языка. Это необходимо как
    для создания удобного доступа к высокоуровневыми вещам, так и к низкоуровневым. Появляется 
    возможность убрать низкоуровневые возможности, когда в них нет нужны или добавить высокоуровневые. Иными
    словами то, что мы обычно привыкли представлять как библиотеки с тем или иным интерфейсом(ООП, модульно-
    процедурным и тд) будет возможно интегрировать прямо в язык ровно так, как это было бы удобно и логично.
    Вот пара примеров:

    var array = int.alloc(4);
    array[2] = 15;

    Достаточно низкоуровнево, и может отсутствовать. Вместо этого может присутствовать такая конструкция
    var array = [0,15,0,0]
    
    А может и такая:
    var array = array(4) int;
    var array[2] = 15;

    Или такая:

    int[4] array
    array[2] = 15

    Ну и ещё пример:

    Вариант в стиле javascript
    let boy = { hello : function(string){
                            print(string)
                        }
              }

    Может быть такой вариант:
    
    object boy {
        method hello with string {
            print string
        }
    }

  - кодогенерация
    В самом простом случае это аналог eval. То есть компилятор как бы подшивается к программе и всегда
    готов к использованию внутри программы. При этом я уже говорил, что реализация языка должна быть простой
    и компактной, это крайне важно. Без этого подшиваемый компилятор будет крайне тяжёл и в итоге все 
    преимущества просто испарятся. Тут уместно сравнить с capsule, которая также компактна и не может быть
    раздута - иначе любое вебприложение, использующиее эти технологии, будет только загружаться полчаса.
    И хотя eval вринципе достаточен, надо подумать как реализовать приемлемый вариант с учётом возможностей
    самомодификации языка.

  Зачем всё это? В основном для двух целей.
  - скрыть все внутренности sphere, dsa, capsule. Сделать работу с ними более естественной. К примеру было
    бы неплохо писать как-то так:
    card 'example'
    click {
        label 'ok'
    }
    вместо
    var example = new card('example', stack);
    if(example.old)
        return;
    new click({ label : 'ok'}, stack);
    Как видно скрывается и явное использование stack и необходимость явного возврата, если card уже 
    существует. Много ручной работы, которую нет смысла делать каждый раз. Это примерно как вместо 
    использования new написать собственную function new_object() и делать кучу связанных с созданием
    объекта вещей вручную. Можно, но неудобно. И чем больше сущность, тем больше подробностей. Необходимо
    абстрагироваться, естественно на уровне языка. Это делает код компактным и понятным. В общем DSL:)

  - эффективно работать на разных платформах.
    Для dsa, sphere, capsule нужен максимум эффективности(скорость, память и тд) среди тех условий, где происходит исполнение.
    Сейчас подобное даёт C или С++, их можно компилировать даже в javascript. Но у них, как и множества их
    альтернатив, просто жутко тяжёлые компиляторы и runtime. Ну и полностью отсутствует meta способности.
* описание
** основа
*** описание
   Предположим, что основа языка похожа на javascript. Но из javascript необходимо убрать все лишние сущности
   для простоты реализации meta и ввести жёсткие требования приведения типов для возможности компиляции.
   Вот список того, что нужно сделать с javascript для получения основы:
  - убрать прототипы
    в целом эта модель хоть и полезна, но не является необходимой. Её как и многое другое можно будет 
    реализовать позже, как meta модификацию
  - убрать оператор new и использование функций как конструкторов. Необходимости в этом особой нет, поскольку
    есть возможность создавать объекты используя {}
  - Встроенные объекты могут создаваться только инициализаторами, то есть прямым присвоением значения 
    переменной. Использование конструкторов типа Array(), Object() и тд невозможно, так как конструкторы
    не поддерживаются(смотрите предыдущий пункт). Также не будет работать instanceof.
  - автоматическое приведение типов допустимо только в однозначных случаях. Переопределение типа переменной
    недопустимо. Например: 
    var num = 15;
    num += 50;
    а затем:
    num += 'hello'; //недопустимо
    num += 15.5; //допустимо, если позволяет размерность
    hello + num; //допустимо
    num = 'hello; //недопустимо
  - поскольку new не работает, то не существует также и конструктор Function. Использовать можно только eval.
    Возможно и eval не нужен, посмотрим.
    
   Это примерный список, что-то может измениться. Какие-то вещи можно будет и сделать, а что-то и ещё надо будет
   убрать.
    
*** назначение и использование
    Основа удобна вот чем:
    -код написанный на ней может быть обработан любой реализацией javascript
    -скомпилирован как обычный компилируемый язык вроде С
    
    Поэтому она выбрана для написание самого компилятора meta. И работать будет поверх любой javascript
    реализации и компилироваться в машинный код подобно тому, как был бы написан на С.
    
** модификация языка
   допустим мы хотим объявлять объект явно, а не присваиванием переменной, вот так:
   object hello {
       method hi{
       }
   }
   
   Для этого нам надо написать модификацию примерно так:
   
   meta.add = {
       keyword : 'object',
       next : {
           name : {
	       type : 'label'
	   },
	   body : {
	       type : 'block'
	   }
       }
       handler : function(context, name, body){
           context.var_add(name, {});
	   meta.add = {
	       keyword : 'method',
	       next : {
	           name : {
		       type : 'label'
		   },
		   body : {
		       type : 'block'
		   }
	       }
	       handler : function(context, mname, body){
	           context.vars[name][mname] = body;
	       }
	   }
       }
   }

   Естественно это лишь грубый и неточный пример. Плюс здесь не разобраны вопросы работы с разделителями.
   Однако в языке управляется всё и как выше уже было сказано, можно убирать даже те конструкции, которые
   есть в основе. Правда в этом случае нужно действовать осторожно, ведь можно сделать код неработоспособным.
   Подобные модификации языка могут встречаться прямо в компилируемом коде, а могут неявно делаться через
   подгрузку модулей, подобно тому как директивы pragma в некоторых языках изменяют поведение компилятора.
   Но здесь важно понимать, что сам компилятор несёт в себе лишь реализацию основы и возможности по 
   модификации. Всю остальную работу делает компилируемый код - явно или через подгрузку другого кода - это
   лишь вопрос метода.
* Примеры
