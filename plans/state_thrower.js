/*
 * Название, хм. Ноги растут из таких понятий как state, stateless, stateful.
 * Понимать название концепта стоит как метатель|пробрасыватель|забасыватель состояния
 * Смысл в том, что у нас есть некоторая сущность, например функция, в ходе своей работы
 * она имеет состояние, то есть все используемые внутри неё переменные формируют его.
 * Когда из этой функции вызывается другая функция, этот вызов происходит из какого-то состояния.
 * Сам вызов также есть часть этого состояния. И это состояние передаётся вызванной функции.
 * По крайней мере буду предполагать так в рамках этой концепции.
 * 
 * К чему это имеет отношения, какие задачи решает:
 * + debug
 *   накопление информации для отладки. Знание где и при каких условиях что происходит, в том числе ошибки
 * + replacement of exceptions for distributed environment
 *   исключения вещь очень локальная, не говоря уже о невозможности хранить не только стек вызовов, а 
 *   состояние всех взаимодействовавших частей. Так вот state_thrower c одной стороны знает обо всех 
 *   взаимодействиях и способен работать в распределённой системе, взаимодействуя с dsa, sequence с другой
 *  
 * + rollback, try again
 *   возможность повторить неудавшиеся операции, откатится на некоторое состояние, сделать иначе.
 *   Накопление состояний позволяет перемещаться между ними, хоть и не так просто:)
 * + statistic, relations of states, profiling 
 *   Накопление статистики состояний позволяет выводить взаимоотношения тех или иных сущностей. Близость
 *   их связей и делать выводы. Также это полезно для профилирование, так как становится известно в каком
 *   месте и сколько раз сделано то или иное действие
 * 
 * К реализации. По началу речь идёт о пробрасывании макросостояний - функция, минимальное описание её 
 * состояния и вызов другой функции. При этом делается это явно и далеко не для каждых функций. Естественно,
 * пробрасываются все вызовы сервисов, то есть на уровне dsa все состояния пробрасываются.
 * state_thrower также планируется для плотной интеграции с sequence, чтобы делать ничего вручную не приходилось
 */

var sthrower = require('parts/state_thrower.js');

function config_read(config_name){ 
    var config;
    try {
	config = JSON.parse(fs.readFileSync(config_name));	
    } catch (x) {
	sthrower.current.fail = x;
    }
    sthrower.current.success = 'config is created';
    return config;
}

function show_window(){
    var config = sthrower.call_and_push(config_read, 'config.json');
    sthrower.current.maximized = config.maximized;
    if(config.maximize)
	main.show('maximize');
    else 
	main.show('normal');
    sthrower.current.success = 'window is showed';
}

sthrower.call_and_push(show_window);
sthrower.call_and_push(show_window);
sthrower.call_and_push(show_window);
sthrower.call_and_push(show_window);

console.log(sthrower.tree);

/*
 * Особо тут пояснять нечего, sthrower используется как запускалка функций, чтобы создавать состояния
 * для каждой функции. Аналог стека вызовов, но с той разницей, что запоминается ВСЁ, все вызовы, в нашем
 * случае четыре show_window.
 * Затем дерево всех состояний распечатывается.
 *  
 */

sequence(sthrower,
	 ['s', id, 'generate_id'],
	 ['s', context.service, 'set', 'id', 'stack.last'])

sequence(sthrower,
	 ['s', id, 'generate_id'],
	 ['s', context.service, 'set', 'id', 'stack.last'])

sequence(['s',sthrower.service, 'collect_tree'],
	 ['fn', function(context, stack, sequence){
	      console.log(stack.last);
	  }]);

/*
 *А это уже интереснее, локальный sthrower не будет держать состояния, которые порадились в результате
 * работы двух цепочек, вызывающих сервис id. Но состояния будут хранится в контексте сервиса id.
 * Для того, чтобы собрать всё дерево воедино, нужно использовать sthrower как сервис, чтобы он вытащил
 * из контекста id состояния.
 * Такой механизм, наряду с возможностью передавать состояние на хранение другому и называется state thrower
 */

