* как дальше жить
  В общем ситуация такая, изначально capsule - это база для JSone и поэтому его как бы нельзя было
  рассматривать как фреймворк общего назначения. Ну то есть сравнивать его скажем c Qt или даже с nodejs
  не стоит. Скорее его можно сравнивать с web api в понимании мозиллы. То есть некоторая песочница с
  расширенным апи для доступа ко всяким вещам. Но если это песочница, то как насчёт http_responder, не
  многовато ли для песочницы? Многовато. Поэтому как ни крути, получается что мы движемся в сторону Qt, но
  развиваем только те направления, которые нам нужны в JSone. Но никаких непреодолимых препятствий сделать
  поддержку работы с файлами или скажем сокетами - нет. 
  Отсюда большой вопрос куда двигаться, пишу это здесь и чтобы в голове не держать и в случае, если capsule
  будет пользоваться кто-то ещё, чтобы прочли и выссказались.

** по deployer
   Сейчас deployer, тот что собирает ваше приложение используя capsule modules работает только под nodejs.
   То для для bootstrap вам необходим nodejs. Потенциально, и я думаю над этим, он сможет работать и под
   gjs и почти на любой платформе, где есть доступ к файловой системе. Поддержка работы deployer на разных
   платформах автоматически принесёт в capsule поддержку работы с файлами. 
   Но есть более интересный вопрос, а стоит ли как-то так изменить deployer, чтобы он работал даже там,
   где нет файлов, скажем в браузере? То есть имеет ли смысл? Изначально я думал так: нужно приспосабливаться
   к условиям, а не создавать свои. Например: публиковать в android play уже собранное приложение, вместо того
   чтобы человека заходил на вебсайт, оно загружалось и у него в браузере собиралось.  Сейчас я продолжаю
   думать также, ибо это самый прямой путь, но есть некоторые сомнения. С другой стороны, ничего не мешает
   отложить обдумывание этого на долго:)

** по модулям
   Это главный вопрос, как уже было сказано выше, сейчас capsule это свой мирок. Но расширить его вполне
   возможно. Нужно лишь определять API, скажем для доступа к файлам, и реализовать его в виде модулей для
   разных платформ. Всё для этого сделанож. Вопрос по API к файлам уже почти решён, ибо от него зависит
   deployer, а deployer я убеждён должен работать максимально native, то есть даже там, где нет nodejs,
   но есть какая-то возможность исполнять полноценные javascript приложения. А коли API к файлам будет,
   также планируюется sound API, то что, socket API чем-то отличается? И да и нет. 
   Изначально, capsule должен был иметь достаточно высокоуровневые API, и так оно сейчас и есть. Скажем
   вместо прямого использования http_requester предпочитается использовать transport. Также и storage.
   По этой причине всякие file, socket API и прочие _не должны_ использоваться приложениями слишком часто,
   напрямую и тд. То есть выходит, что всё API будет делится на highlevel и lowlevel. Но тем не менее,
   причина почему в capsule highlevel API в почёте всё ещё здесь - (javascript, он вам не С с точки зрения
   производительности и писать на нём используя низкоуровневые api мягко говоря не очень эффективно). Эта
   причина может быть устранена только используя подход, описанный в metaproto, но это будет когда? Через
   лет тысячу! Поэтому пока я считаю так - lovlevel api могут появляться и будут появляться, но не должны
   широко использоваться, это было бы ошибкой.
** capsule, capsule, new capsule
*** краткое описание
   В общем уже давно, и где-то в документации наверное есть следы, думал о том чтобы можно было создавать
   capsule не только с помощью внешних инструментов(теперь это deployer), но и изнутри. Теперь пришло время
   об этом написать и начать уже двигаться. Что это даёт?:
   - возможность порождать процессы или потоки
     Строго говоря скорее процессы, чем потоки, но об этом дальше. Почему не всякие fork, clone и прощие
     create_proccess? Потому что нам важно не только создать отдельную нить, начинающуюся с некоторой
     функции. Нам важно получить полноценную capsule, с которой ещё было бы возможно относительно легко
     взаимодействовать. Без этого грошь цена, без простоты создания и простоты взаимодействия подобные
     возможности не будут использоваться как и не используются подавляющим числом приложением. А вот если
     нужно что-то кроме простого создания потока, то здесь fork или clone как минимум недостаточны( нужно
     же ещё простое средство коммуникации сообщениями). Но ещё и вредны, ведь кучу контекстов надо
     пересоздавать заново(новый duktape, частично новые модули и тд)

   - песочницы, изоляция кода, конфигурация
     здесь в основном для того, чтобы выполнять некоторый код предназначенный для строго определённых целей
     и предоставлять ему соответствующие возможности. Это не обязательно именно изоляция, скорее конфигурация
     среды. Например ui код может иметь доступ до Compositer и одновременно с этим иметь б'ольший приоритет.
     
*** Как это работает? 
    Естественно, что по разному в зависимости от платформы. В этом вообще вся суть capsule. Но всё таки в 
    одинаково в некотором смысле. Поэтому парочка примеров я думаю опишет ситуацию:
    + nodejs
      через child process создаётся отдельный процесс. Тут возможен вариант с fork + реинициализация, 
      посмотрим, но скорее всего exec с образом capsule + необходимая инициализация.
      В любом случае получается полностью самостоятельный процесс, от которого отключаются все родительские
      дескрипторы. Взаимодействие идёт с помощью сообщений. 

    + gjs
      через spawn_async. Впринципе также как и nodejs, разница тут не большая.
     
    + browser
      через webworker. Почти как и выше, но с той разницей, что в браузере webworker не имеет доступа к DOM,
      но подобные ограничения то есть то нет у разных платформ. Где-то можно сделать множество Compositer,
      как gjs, win32, а где-то только один - web, android. И причины ограничений часто разные.
      В общем здесь создаётся webworker с самостоятельным образом capsule и идёт с ним взаимодействие.

    + win32
      через CreateProcess. Похоже на nodejs и gjs, но тут просто создаётся cbc процесс с образом капсулы.

    У выше описанных случаев много общего, но и может быть много разного. Например способ взаимодействия.
    Во всех случаях используется интерфейс transport. Но реализация его разная, впрочем это свойственна 
    capsule в целом - единые интерфейсы, но разные реализации. В win32, gjs, nodejs разные capsule могут
    общаться с помощью pipe, sockets. А вот в web это уже собственный способ отправки сообщений webworker.

    Тут важно понять, что подход в создании новых capsule это скорее способ разбить приложение на множество 
    независимых модулей-процессов, нежели такие вещи как cluster в nodejs или те же webworker в чистом виде.
    А используемые там идеи вряд ли можно рассматривать как полезные и простые. Значит ли это, что new capsule
    нельзя использовать как ускоритель числодробления? Скорее да, чем нет. По крайней мере пока мы работаем
    с javascript, а не с когда-нибудь придущим  metalang это верно. Числодробить надо снизу, на уровне С.
    
*** API
    Простейший пример:
    //ui.js
    var timer = require('modules/timer');
    timer.create(function(){ ui.destroy()}, 10000, false);
    modules.parent_transport.on_msg(function(body){console.log(body)});
    //capsulated.js
    var ui = new capsule('ui', { modules : 'Compositer'));
    ui.send("hello");
    ui.destroy();
    
    Впринципе тут ничего такого неясного нет. Создаётся ещё одна капсула, которая стартует с модуля ui и
    которой доступен только Compositer. Естественно, ей доступен ещё базовый набор модулей, без которых
    вообще сложно что-то сделать, но и это настраиваемо.
    Доступные модули можно посмотреть в объекте modules.
    Затем посылается сообщение новосозданной капсуле, оно принимается и отпечатывается.
    Поскольку транспорты можно прикручивать к dsa.mq, то получается, что каждый модуль сможет взаимодействовать
    с множеством модулей, если вам это нужно, но это уже не дело capsule, это слой выше. Забегая немного
    вперёд скажу, что в JSone предполагаются специальные механизмы для упрощения работы с этими возможностями
    и интеграции их в сервисы, чтобы как можно меньше нужно было заниматься вознёй.

    В зависимости от платформы, созданные capsule как могут жить самостоятельно после смерти родителя( если
    это самостоятельные процессы), так и умирать вместе с ним(если это потоки или webworker). Но в рамках
    capsule API мы считаем, что самостоятельно они не умирают и в коде _обязательно_ должны быть механизмы
    самозавершения. В нашем случае это простейшее самозавершение по таймеру, но обычно, в работающем коде,
    это должно быть завершение, если никакой работы нет и не предвидится(умер родитель, не передаётся 
    обязательный регулярный тик)
    
