/*
 * Хотя изначально, эта идея разработана для последовательного посыла сообщений, от одного другому третьему
 * сервису в рамках проекта sphere, здесь будет описана концепция в целом и приминительно к capsule.
 * А в сфере будет описано в коде приминительно к сервисам и будет реализация этой концепции в 
 * dsa.send_sequense. 
 * В то же время здесь, будут в основном идеи и прототипная часть, а воплощение будет только после завершения
 * всех работ с капсулой, включая чистку кода. Возможно во время чистки появится воплощение, но загадывать 
 * не буду. Главное сейчас описать всё что в голове:) В итоге должно появиться универсальное решение для 
 * капсулы и dsa, которое просто будет иметь опциональную поддержку dsa и других механизмов
 * И небольшая историческая справка, идея последовательности вызовов с сохранением результатов вызовов, 
 * появилая у меня ещё несколько лет назад, во время работы над первым поколением ui, до Compositer. Я тогда
 * не знал, что идея, повторится в голове но в другом виде:) Хотя конечно, может это всё виноваты другие 
 * технологии, которые изучал:) 
 */

sequent(['c', fs.readFile, './sequent_proto.js'],
	['c', fs.writeFile, './sequent_proto.js.copy', 'ret[0][0]'],
	function(ret){
	    //печатаем текст файла
	    console.log(ret[0][0])
	}
       );

/*
 * Некоторые замечания
 * ret - массив хранит все результаты работы вызванных функций в последовательности
 * Сначала вся последовательность обрабатывается, и для тех где надо, создаются реальные функции, а уже 
 * затем последовательность запускается. В нашем случае fs.writeFile оборачивается в функцию, которая уже 
 * передаётся в качестве параметра fs.readFile
 */

sequent(['c', fs.readFile, './sequent_proto.js'],
	['s', 'storage', 'create', {'backend' : 'srb'}],
	function(ret){
	    //печатаем object_info для нахождения нашего файла
	    console.log(ret[1][0])
	},
	['s', 'storage', 'extract', 'ret[1][0]', '*'],
	['c', fs.writeFile, './sequent_proto.js.copy', 'ret[3][0]'],
	function(ret){
	    //печатаем содержимое файла
	    console.log(ret[3][0])
	}
       );

/*
 * с - function with callback. Функция, где последний аргумент это callback, который вызывается,
 * когда дело, ради которой функцию вызвали - сделано. Поскольку существует множество различных соглашений
 * среди функций, делающих дело асинхронно(одни принимают один callback, другие несколько, одни в начале, 
 * другие в конце, а иные и возвращают некий объект, с помощью которого можно назначить callback или узнать
 * статус операции. В силу всего этого, function with callback будет иметь бекэнды, и когда то или иное 
 * соглашение не будет укладываться в концепт function with callback, будет добавлен ещё один тип
 * s - service. Сервис в рамках концепции dsa, то есть посыл ему сообщения. Тут тоже есть нюасны, так как
 * сервис может посылать в ответ разные сообщения, то надо доработать на какие сообщения реагировать и как
 * 
 */